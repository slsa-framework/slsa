---
title: Build Provenance
description: The software supply chain is divided into different types of activities that are needed to produce software artifacts: build, build environment, dependency, and source. This page covers the provenance of the build track portion of the supply chain.
---

# Build Provenance

This page covers the provenance of the build track portion of the supply chain.

Other pages in this section cover the following topics directly related to the build track:

1. [Build: Track Basics](build-track-basics.md)
2. [Build: Requirements](build-requirements.md)
3. [Build: Attestation formats](build-attestation.md)
4. [Build: Verification systems](build-verification.md)

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119).

## Build Provenance Overview

The producer MUST generate and distribute provenance to artifact consumers. The producer
MAY delegate this responsibility to the
[package ecosystem], provided that the package ecosystem is capable of
distributing provenance.

### Provenance generation

[Provenance generation]: #provenance-generation

The build platform is responsible for generating provenance describing how the
package was produced.

The SLSA Build level describes the overall provenance integrity according to
minimum requirements on its:

-   *Completeness:* What information is contained in the provenance?
-   *Authenticity:* How strongly can the provenance be tied back to the builder?
-   *Accuracy:* How resistant is the provenance generation to tampering within
    the build process?

<table>
<tr><th>Requirement<th>Description<th>L1<th>L2<th>L3

<tr id="provenance-exists"><td>Provenance Exists<td>

The build process MUST generate provenance that unambiguously identifies the
output package by cryptographic digest and describes how that package was
produced. The format MUST be acceptable to the [package ecosystem] and/or
[consumer](verifying-artifacts.md#consumer).

It is RECOMMENDED to use the [SLSA Provenance] format and [associated suite]
because it is designed to be interoperable, universal, and unambiguous when
used for SLSA. See that format's documentation for requirements and
implementation guidelines.

If using an alternate format, it MUST contain the equivalent information as SLSA
Provenance at each level and SHOULD be bi-directionally translatable to SLSA
Provenance.

-   *Completeness:* Best effort. The provenance at L1 SHOULD contain sufficient
    information to catch mistakes and simulate the user experience at higher
    levels in the absence of tampering. In other words, the contents of the
    provenance SHOULD be the same at all Build levels, but a few fields MAY be
    absent at L1 if they are prohibitively expensive to implement.
-   *Authenticity:* No requirements.
-   *Accuracy:* No requirements.

[SLSA Provenance]: provenance.md
[associated suite]: ../../attestation-model#recommended-suite

<td>✓<td>✓<td>✓
<tr id="provenance-authentic"><td>Provenance is Authentic<td>

*Authenticity:* Consumers MUST be able to validate the authenticity of the
provenance attestation in order to:

-   *Ensure integrity:* Verify that the digital signature of the provenance
    attestation is valid and the provenance was not tampered with after the
    build.
-   *Define trust:* Identify the build platform and other entities that are
    necessary to trust in order to trust the artifact they produced.

This SHOULD be through a digital signature from a private key accessible only
to the build platform component that generated the provenance attestation.

While many constraints affect choice of signing methodologies, it is
RECOMMENDED that build platforms use signing methodologies which improve the
ability to detect and remediate key compromise, such as methods which rely on
transparency logs or, when transparency isn't appropriate, time stamping
services.

Authenticity allows the consumer to trust the contents of the provenance
attestation, such as the identity of the build platform.

*Accuracy:* The provenance MUST be generated by the control plane (i.e. within
the trust boundary [identified in the provenance]) and not by a tenant of the
build platform (i.e. outside the trust boundary), except as noted below.

-   The data in the provenance MUST be obtained from the build platform, either
    because the generator *is* the build platform or because the provenance
    generator reads the data directly from the build platform.
-   The build platform MUST have some security control to prevent tenants from
    tampering with the provenance. However, there is no minimum bound on the
    strength. The purpose is to deter adversaries who might face legal or
    financial risk from evading controls.
-   Exceptions for fields that MAY be generated by a tenant of the build platform:
    -   The names and cryptographic digests of the output artifacts, i.e.
        `subject` in [SLSA Provenance]. See [forge output digest of the
        provenance](threats#forged-digest) for explanation of why this is
        acceptable.
    -   Any field that is not marked as REQUIRED for Build L2. For example,
        `resolvedDependencies` in [SLSA Provenance] MAY be tenant-generated at
        Build L2. Builders SHOULD document any such cases of tenant-generated
        fields.

*Completeness:* SHOULD be complete.

-   There MAY be [external parameters] that are not sufficiently captured in
    the provenance.
-   Completeness of resolved dependencies is best effort.

<td> <td>✓<td>✓
<tr id="provenance-unforgeable"><td>Provenance is Unforgeable<td>

*Accuracy:* Provenance MUST be strongly resistant to forgery by tenants.

-   Any secret material used for authenticating the provenance, for example the
    signing key used to generate a digital signature, MUST be stored in a secure
    management system appropriate for such material and accessible only to the
    build service account.
-   Such secret material MUST NOT be accessible to the environment running
    the user-defined build steps.
-   Every field in the provenance MUST be generated or verified by the build
    platform in a trusted control plane. The user-controlled build steps MUST
    NOT be able to inject or alter the contents, except as noted in [Provenance
    is Authentic](#provenance-authentic). (Build L3 does not require additional
    fields beyond those of L2.)

*Completeness:* SHOULD be complete.

-   [External parameters] MUST be fully enumerated.
-   Completeness of resolved dependencies is best effort.

Note: This requirement was called "non-falsifiable" in the initial
[draft version (v0.1)](../v0.1/requirements.md#non-falsifiable).

<td> <td> <td>✓
</table>

### Isolation strength

[Isolation strength]: #isolation-strength
[Isolation between builds]: #isolation-strength

The build platform is responsible for isolating between builds, even within the
same tenant project. In other words, how strong of a guarantee do we have that
the build really executed correctly, without external influence?

The SLSA Build level describes the minimum bar for isolation strength. For more
information on assessing a build platform's isolation strength, see
[Assessing build platforms](assessing-build-platforms.md).

<table>
<tr><th>Requirement<th>Description<th>L1<th>L2<th>L3

<tr id="hosted">
<td>Hosted
<td>

All build steps ran using a hosted build platform on shared or dedicated
infrastructure, not on an individual's workstation.

Examples: GitHub Actions, Google Cloud Build, Travis CI.

<td> <td>✓<td>✓
<tr id="isolated">
<td>Isolated
<td>

The build platform ensured that the build steps ran in an isolated environment,
free of unintended external influence. In other words, any external influence on
the build was specifically requested by the build itself. This MUST hold true
even between builds within the same tenant project.

The build platform MUST guarantee the following:

-   It MUST NOT be possible for a build to access any secrets of the build
    platform, such as the provenance signing key, because doing so would
    compromise the authenticity of the provenance.
-   It MUST NOT be possible for two builds that overlap in time to influence one
    another, such as by altering the memory of a different build process running
    on the same machine.
-   It MUST NOT be possible for one build to persist or influence the build
    environment of a subsequent build. In other words, an ephemeral build
    environment MUST be provisioned for each build.
-   It MUST NOT be possible for one build to inject false entries into a build
    cache used by another build, also known as "cache poisoning". In other
    words, the output of the build MUST be identical whether or not the cache is
    used.
-   The build platform MUST NOT open services that allow for remote influence
    unless all such interactions are captured as `externalParameters` in the
    provenance.

There are no sub-requirements on the build itself. Build L3 is limited to
ensuring that a well-intentioned build runs securely. It does not require that
a build platform prevents a producer from performing a risky or insecure build. In
particular, the "Isolated" requirement does not prohibit a build from calling
out to a remote execution service or a "self-hosted runner" that is outside the
trust boundary of the build platform.

NOTE: This requirement was split into "Isolated" and "Ephemeral Environment"
in the initial [draft version (v0.1)](../v0.1/requirements.md).

NOTE: This requirement is not to be confused with "Hermetic", which roughly
means that the build ran with no network access. Such a requirement requires
substantial changes to both the build platform and each individual build, and is
considered in the [future directions](future-directions.md).

<td> <td> <td>✓
</table>

[external parameters]: provenance.md#externalParameters
[identified in the provenance]: provenance.md#model
[package ecosystem]: verifying-artifacts.md#package-ecosystem

### Distributing provenance

To trace software back to the source and define the moving parts in a complex
supply chain, provenance needs to be there from the very beginning. It's the
verifiable information about software artifacts describing where, when, and how
something was produced. For higher SLSA levels and more resilient integrity
guarantees, provenance requirements are stricter and need a deeper, more
technical understanding of the predicate.

This document defines the following predicate type within the [in-toto
attestation] framework:

```json
"predicateType": "https://slsa.dev/provenance/v1"
```

> Important: Always use the above string for `predicateType` rather than what is
> in the URL bar. The `predicateType` URI will always resolve to the latest
> minor version of this specification. See [parsing rules](#parsing-rules) for
> more information.

## Purpose

Describe how an artifact or set of artifacts was produced so that:

-   Consumers of the provenance can verify that the artifact was built according
    to expectations.
-   Others can rebuild the artifact, if desired.

This predicate is the RECOMMENDED way to satisfy the SLSA v1.0 [provenance
requirements](requirements#provenance-generation).

## Model

Provenance is an attestation that a particular build platform produced a set of
software artifacts through execution of the `buildDefinition`.

![Build Model](images/provenance-model.svg)

> NOTE: This diagram depicts how the SLSA Provenance format is structured.  It
> elaborates on the [SLSA Build Model](terminology#build-model) but only applies
> to the SLSA Provenance format specifically and not to builds in general.

The model is as follows:

-   Each build runs as an independent process on a multi-tenant build platform.
    The `builder.id` identifies this platform, representing the transitive
    closure of all entities that are [trusted] to faithfully run the build and
    record the provenance. (Note: The same model can be used for platform-less
    or single-tenant build platforms.)

    -   The build platform implementer SHOULD define a security model for the build
        platform in order to clearly identify the platform's boundaries, actors,
        and interfaces. This model SHOULD then be used to identify the transitive
        closure of the trusted build platform for the `builder.id` as well as the
        trusted control plane.

-   The build process is defined by a parameterized template, identified by
    `buildType`. This encapsulates the process that ran, regardless of what
    platform ran it. Often the build type is specific to the build platform
    because most build platforms have their own unique interfaces.

-   All top-level, independent inputs are captured by the parameters to the
    template. There are two types of parameters:

    -   `externalParameters`: the external interface to the build. In SLSA,
        these values are untrusted; they MUST be included in the provenance and
        MUST be verified downstream.

    -   `internalParameters`: set internally by the platform. In SLSA, these
        values are trusted because the platform is trusted; they are OPTIONAL
        and need not be verified downstream. They MAY be included to enable
        reproducible builds, debugging, or incident response.

-   All artifacts fetched during initialization or execution of the build
    process are considered dependencies, including those referenced directly by
    parameters. The `resolvedDependencies` captures these dependencies, if
    known. For example, a build that takes a git repository URI as a parameter
    might record the specific git commit that the URI resolved to as a
    dependency.

-   During execution, the build process might communicate with the build
    platform's control plane and/or build caches. This communication is not
    captured directly in the provenance, but is instead implied by `builder.id`
    and subject to [SLSA Requirements](requirements.md). Such
    communication SHOULD NOT influence the definition of the build; if it does,
    it SHOULD go in `resolvedDependencies` instead.

-   Finally, the build process outputs one or more artifacts, identified by
    `subject`.

For concrete examples, see [index of build types](#index-of-build-types).

## Parsing rules

This predicate follows the in-toto attestation [parsing rules]. Summary:

-   Consumers MUST ignore unrecognized fields unless otherwise noted.
-   The `predicateType` URI includes the major version number and will always
    change whenever there is a backwards incompatible change.
-   Minor version changes are always backwards compatible and "monotonic."
    Such changes do not update the `predicateType`.
-   Unset, null, and empty field values MUST be interpreted equivalently.

## Schema

### Summary

*NOTE: This summary (in cue) is informative. In the event of a
disagreement with the text description, the text is authoritative.*

<!-- Note: While this happens to be a valid cue file, we're really just using it
as a human-readable summary of the schema. We don't want readers to have to
understand cue. For that reason, we are not using any special cue syntax or
features. -->

```javascript
{% include_relative schema/provenance.cue %}
```

<details>
<summary>Protocol buffer schema</summary>

*NOTE: This summary (in protobuf) is informative. In the event of a
disagreement with the text description, the text is authoritative.*

Link: [provenance.proto](schema/provenance.proto)

*NOTE: This protobuf definition prioritizes being a human-readable summary
of the schema for readers of the specification. A version of the protobuf
definition useful for code generation is maintained in the
[in-toto attestation] repository.*

```proto
{% include_relative schema/provenance.proto %}
```

</details>

### Provenance

*NOTE: This section describes the fields within `predicate`. For a description
of the other top-level fields, such as `subject`, see [Statement].*

[Provenance]: #provenance

REQUIRED for SLSA Build L1: `buildDefinition`, `runDetails`

<table>
<tr><th>Field<th>Type<th>Description

<tr id="buildDefinition"><td><code>buildDefinition</code>
<td><a href="#builddefinition">BuildDefinition</a><td>

The input to the build. The accuracy and completeness are implied by
`runDetails.builder.id`.

<tr id="runDetails"><td><code>runDetails</code>
<td><a href="#rundetails">RunDetails</a><td>

Details specific to this particular execution of the build.

</table>

### BuildDefinition

[BuildDefinition]: #builddefinition

REQUIRED for SLSA Build L1: `buildType`, `externalParameters`

<table>
<tr><th>Field<th>Type<th>Description

<tr id="buildType"><td><code>buildType</code>
<td>string (<a href="https://github.com/in-toto/attestation/blob/7aefca35a0f74a6e0cb397a8c4a76558f54de571/spec/v1/field_types.md#typeuri">TypeURI</a>)<td>

Identifies the template for how to perform the build and interpret the
parameters and dependencies.

The URI SHOULD resolve to a human-readable specification that includes: overall
description of the build type; schema for `externalParameters` and
`internalParameters`; unambiguous instructions for how to initiate the build given
this BuildDefinition, and a complete example. Example:
https://slsa-framework.github.io/github-actions-buildtypes/workflow/v1

<tr id="externalParameters"><td><code>externalParameters</code>
<td>object<td>

The parameters that are under external control, such as those set by a user or
tenant of the build platform. They MUST be complete at SLSA Build L3, meaning that
there is no additional mechanism for an external party to influence the
build. (At lower SLSA Build levels, the completeness MAY be best effort.)

The build platform SHOULD be designed to minimize the size and complexity of
`externalParameters`, in order to reduce fragility and ease [verification].
Consumers SHOULD have an expectation of what "good" looks like; the more
information that they need to check, the harder that task becomes.

Verifiers SHOULD reject unrecognized or unexpected fields within
`externalParameters`.

<tr id="internalParameters"><td><code>internalParameters</code>
<td>object<td>

The parameters that are under the control of the entity represented by
`builder.id`. The primary intention of this field is for debugging, incident
response, and vulnerability management. The values here MAY be necessary for
reproducing the build. There is no need to [verify][Verification] these
parameters because the build platform is already trusted, and in many cases it is
not practical to do so.

<tr id="resolvedDependencies"><td><code>resolvedDependencies</code>
<td>array (<a href="https://github.com/in-toto/attestation/blob/7aefca35a0f74a6e0cb397a8c4a76558f54de571/spec/v1/resource_descriptor.md">ResourceDescriptor</a>)<td>

Unordered collection of artifacts needed at build time. Completeness is best
effort, at least through SLSA Build L3. For example, if the build script
fetches and executes "example.com/foo.sh", which in turn fetches
"example.com/bar.tar.gz", then both "foo.sh" and "bar.tar.gz" SHOULD be
listed here.

</table>

The BuildDefinition describes all of the inputs to the build. It SHOULD contain
all the information necessary and sufficient to initialize the build and begin
execution.

The `externalParameters` and `internalParameters` are the top-level inputs to the
template, meaning inputs not derived from another input. Each is an arbitrary
JSON object, though it is RECOMMENDED to keep the structure simple with string
values to aid verification. The same field name SHOULD NOT be used for both
`externalParameters` and `internalParameters`.

The parameters SHOULD only contain the actual values passed in through the
interface to the build platform. Metadata about those parameter values,
particularly digests of artifacts referenced by those parameters, SHOULD instead
go in `resolvedDependencies`. The documentation for `buildType` SHOULD explain
how to convert from a parameter to the dependency `uri`. For example:

```json
"externalParameters": {
    "repository": "https://github.com/octocat/hello-world",
    "ref": "refs/heads/main"
},
"resolvedDependencies": [{
    "uri": "git+https://github.com/octocat/hello-world@refs/heads/main",
    "digest": {"gitCommit": "7fd1a60b01f91b314f59955a4e4d4e80d8edf11d"}
}]
```

Guidelines:

-   Maximize the amount of information that is implicit from the meaning of
    `buildType`. In particular, any value that is boilerplate and the same
    for every build SHOULD be implicit.

-   Reduce parameters by moving configuration to input artifacts whenever
    possible. For example, instead of passing in compiler flags via an external
    parameter that has to be [verified][Verification] separately, require the
    flags to live next to the source code or build configuration so that
    verifying the latter automatically verifies the compiler flags.

-   In some cases, additional external parameters might exist that do not impact
    the behavior of the build, such as a deadline or priority. These extra
    parameters SHOULD be excluded from the provenance after careful analysis
    that they indeed pose no security impact.

-   If possible, architect the build platform to use this definition as its
    sole top-level input, in order to guarantee that the information is
    sufficient to run the build.

-   When build configuration is evaluated client-side before being sent to the
    server, such as transforming version-controlled YAML into ephemeral JSON,
    some solution is needed to make [verification] practical. Consumers need a
    way to know what configuration is expected and the usual way to do that is
    to map it back to version control, but that is not possible if the server
    cannot verify the configuration's origins. Possible solutions:

    -   (RECOMMENDED) Rearchitect the build platform to read configuration
        directly from version control,  recording the server-verified URI in
        `externalParameters` and the digest in `resolvedDependencies`.

    -   Record the digest in the provenance[^digest-param] and use a separate
        provenance attestation to link that digest back to version control. In
        this solution, the client-side evaluation is considered a separate
        "build" that SHOULD be independently secured using SLSA, though securing
        it can be difficult since it usually runs on an untrusted workstation.

-   The purpose of `resolvedDependencies` is to facilitate recursive analysis of
    the software supply chain. Where practical, it is valuable to record the
    URI and digest of artifacts that, if compromised, could impact the build. At
    SLSA Build L3, completeness is considered "best effort".

[^digest-param]: The `externalParameters` SHOULD reflect reality. If clients
    send the evaluated configuration object directly to the build server, record
    the digest directly in `externalParameters`. If clients upload the
    configuration object to a temporary storage location and send that location
    to the build server, record the location in `externalParameters` as a URI
    and record the `uri` and `digest` in `resolvedDependencies`.

### RunDetails

[RunDetails]: #rundetails

REQUIRED for SLSA Build L1: `builder`

<table>
<tr><th>Field<th>Type<th>Description

<tr id="runDetailsBuilder"><td><code>builder</code>
<td><a href="#builder">Builder</a><td>

Identifies the build platform that executed the invocation, which is trusted to
have correctly performed the operation and populated this provenance.

<tr id="runDetailsMetadata"><td><code>metadata</code>
<td><a href="#buildmetadata">BuildMetadata</a><td>

Metadata about this particular execution of the build.

<tr id="runDetailsByproducts"><td><code>byproducts</code>
<td>array (<a href="https://github.com/in-toto/attestation/blob/7aefca35a0f74a6e0cb397a8c4a76558f54de571/spec/v1/resource_descriptor.md">ResourceDescriptor</a>)<td>

Additional artifacts generated during the build that are not considered
the "output" of the build but that might be needed during debugging or
incident response. For example, this might reference logs generated during
the build and/or a digest of the fully evaluated build configuration.

In most cases, this SHOULD NOT contain all intermediate files generated during
the build. Instead, this SHOULD only contain files that are likely to be useful
later and that cannot be easily reproduced.

</table>

### Builder

[Builder]: #builder

REQUIRED for SLSA Build L1: `id`

<table>
<tr><th>Field<th>Type<th>Description

<tr id="builder.id"><td><code>id</code>
<td>string (<a href="https://github.com/in-toto/attestation/blob/7aefca35a0f74a6e0cb397a8c4a76558f54de571/spec/v1/field_types.md#typeuri">TypeURI</a>)<td>

URI indicating the transitive closure of the trusted build platform. This is
[intended](verifying-artifacts#step-1-check-slsa-build-level)
to be the sole determiner of the SLSA Build level.

If a build platform has multiple modes of operations that have differing
security attributes or SLSA Build levels, each mode MUST have a different
`builder.id` and SHOULD have a different signer identity. This is to minimize
the risk that a less secure mode compromises a more secure one.

The `builder.id` URI SHOULD resolve to documentation explaining:

-   The scope of what this ID represents.
-   The claimed SLSA Build level.
-   The accuracy and completeness guarantees of the fields in the provenance.
-   Any fields that are generated by the tenant-controlled build process and not
    verified by the trusted control plane, except for the `subject`.
-   The interpretation of any extension fields.

<tr id="builderDependencies"><td><code>builderDependencies</code>
<td>array (<a href="https://github.com/in-toto/attestation/blob/7aefca35a0f74a6e0cb397a8c4a76558f54de571/spec/v1/resource_descriptor.md">ResourceDescriptor</a>)<td>

Dependencies used by the orchestrator that are not run within the workload
and that do not affect the build, but might affect the provenance generation
or security guarantees.

<tr id="builder.version"><td><code>version</code>
<td>map (string→string)<td>

Map of names of components of the build platform to their version.

</table>

The build platform, or <dfn>builder</dfn> for short, represents the transitive
closure of all the entities that are, by necessity, [trusted] to faithfully run
the build and record the provenance. This includes not only the software but the
hardware and people involved in running the service. For example, a particular
instance of [Tekton](https://tekton.dev/) could be a build platform, while
Tekton itself is not. For more info, see [Build
model](terminology#build-model).

The `id` MUST reflect the trust base that consumers care about. How detailed to
be is a judgement call. For example, GitHub Actions supports both GitHub-hosted
runners and self-hosted runners. The GitHub-hosted runner might be a single
identity because it's all GitHub from the consumer's perspective. Meanwhile,
each self-hosted runner might have its own identity because not all runners are
trusted by all consumers.

Consumers MUST accept only specific signer-builder pairs. For example, "GitHub"
can sign provenance for the "GitHub Actions" builder, and "Google" can sign
provenance for the "Google Cloud Build" builder, but "GitHub" cannot sign for
the "Google Cloud Build" builder.

Design rationale: The builder is distinct from the signer in order to support
the case where one signer generates attestations for more than one builder, as
in the GitHub Actions example above. The field is REQUIRED, even if it is
implicit from the signer, to aid readability and debugging. It is an object to
allow additional fields in the future, in case one URI is not sufficient.

### BuildMetadata

[BuildMetadata]: #buildmetadata

REQUIRED: (none)

<table>
<tr><th>Field<th>Type<th>Description

<tr id="invocationId"><td><code>invocationId</code>
<td>string<td>

Identifies this particular build invocation, which can be useful for finding
associated logs or other ad-hoc analysis. The exact meaning and format is
defined by `builder.id`; by default it is treated as opaque and case-sensitive.
The value SHOULD be globally unique.

<tr id="startedOn"><td><code>startedOn</code>
<td>string (<a href="https://github.com/in-toto/attestation/blob/7aefca35a0f74a6e0cb397a8c4a76558f54de571/spec/v1/field_types.md#timestamp">Timestamp</a>)<td>

The timestamp of when the build started.

<tr id="finishedOn"><td><code>finishedOn</code>
<td>string (<a href="https://github.com/in-toto/attestation/blob/7aefca35a0f74a6e0cb397a8c4a76558f54de571/spec/v1/field_types.md#timestamp">Timestamp</a>)<td>

The timestamp of when the build completed.

</table>

### Extension fields

[Extension fields]: #extension-fields

Implementations MAY add extension fields to any JSON object to describe
information that is not captured in a standard field. Guidelines:

-   Extension fields SHOULD use names of the form `<vendor>_<fieldname>`, e.g.
    `examplebuilder_isCodeReviewed`. This practice avoids field name collisions
    by namespacing each vendor. Non-extension field names never contain an
    underscore.
-   Extension fields MUST NOT alter the meaning of any other field. In other
    words, an attestation with an absent extension field MUST be interpreted
    identically to an attestation with an unrecognized (and thus ignored)
    extension field.
-   Extension fields SHOULD follow the [monotonic principle][parsing rules],
    meaning that deleting or ignoring the extension SHOULD NOT turn a DENY
    decision into an ALLOW.

